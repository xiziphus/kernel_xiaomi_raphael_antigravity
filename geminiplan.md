Comprehensive Engineering Strategy for Advanced Kernel Compilation: Enabling Docker and KernelSU on Redmi K20 Pro (Raphael) for Android 151. Executive Summary and Architectural Overview1.1 Project Scope and Strategic ObjectivesThe convergence of mobile telephony hardware and server-grade virtualization technologies represents a significant frontier in embedded systems engineering. This report articulates a rigorous, exhaustive technical plan to engineer a custom Linux kernel for the Xiaomi Redmi K20 Pro (device codename: raphael). The primary objective is to synthesize a kernel capable of supporting Android 15 (A15) while concurrently enabling native Docker containerization and Kernel-based SuperUser (KernelSU) privileges.This endeavor is non-trivial due to the architectural bifurcation between the legacy Qualcomm Snapdragon 855 (SM8150) platform, which relies on the Linux 4.14 Long Term Support (LTS) kernel, and the modern requirements of Android 15, which generally anticipate Generic Kernel Image (GKI) compliance based on Linux 5.10 or newer.1 The project is further constrained by the host build environment—an Intel-based Apple MacBook Pro—which necessitates a containerized compilation workflow to mitigate cross-platform binary incompatibility and filesystem case-sensitivity issues.3The analysis determines that a successful outcome requires a tripartite engineering approach:Environment Virtualization: Establishing a hermetic Docker-based build silo on the macOS host to standardize the toolchain (Clang/LLVM) and dependencies.Source Code Adaptation: Utilizing the etnperlong/kernel_xiaomi_raphael_bool-x repository, which bridges the gap between legacy hardware drivers and Android 15 userspace requirements, while integrating KernelSU source code directly into the tree.5Configuration Hardening: Systematically modifying the kernel configuration (defconfig) to activate the specific namespaces, control groups (cgroups), and filesystem drivers required by the Moby/Docker runtime, without compromising the stability of the Android runtime (ART).61.2 Hardware Platform Analysis: Snapdragon 855 (SM8150)The Redmi K20 Pro utilizes the Qualcomm Snapdragon 855 SoC, a 7nm chipset featuring a tri-cluster CPU architecture (1x Prime Core, 3x Performance Cores, 4x Efficiency Cores). While this architecture offers significant compute power sufficient for running lightweight server containers, the underlying Board Support Package (BSP) is tethered to Linux Kernel 4.14.8This version lock presents a "GKI Gap." Google's Project Treble and subsequent architectural shifts in Android 12 through 15 have moved towards modular kernels (GKI). However, raphael remains on a monolithic kernel structure where drivers for the Adreno 640 GPU, Hexagon DSP, and Spectra ISP are tightly coupled with the kernel image. Consequently, one cannot simply upgrade the kernel to 5.10 or 6.1 to gain native Docker features; one must backport features or enable dormant configurations within the 4.14 tree.5The implications for Docker are significant. Modern container runtimes default to cgroup v2 and recent eBPF (Extended Berkeley Packet Filter) capabilities. The 4.14 kernel supports cgroup v1 primarily, and lacks full eBPF feature parity. Therefore, the compilation plan must account for legacy cgroup mounting strategies in userspace to ensure the Docker daemon (dockerd) can interface effectively with the kernel's resource controllers.51.3 Android 15 Userspace CompatibilityRunning Android 15 on this device relies on the "Evolution X" or "LineageOS" ecosystem, which utilizes "shims" and hacks to make the proprietary Android 10/11-era vendor blobs function with Android 15.1 The selected kernel source must align with these ROMs. The etnperlong kernel is explicitly identified as active and compatible with Android 14/15 (A14/A15) userspace, evidenced by recent commits adjusting erofs (Enhanced Read-Only File System) and lz4 compression, which are critical for mounting the system partitions in modern Android builds.52. The Host Build Environment: macOS Intel Virtualization2.1 The Challenge of Darwin vs. LinuxCompiling an Android kernel (which is fundamentally Linux) on macOS (Darwin kernel) presents immediate compatibility hurdles. The most critical is filesystem case sensitivity. The Linux kernel source tree contains files that may conflict on a case-insensitive filesystem (APFS default). Furthermore, the ELF (Executable and Linkable Format) binaries used in the Android toolchain are compiled for x86_64 Linux, not macOS.11While cross-compilation toolchains for macOS exist, they often lag behind or introduce subtle linking errors. A "Hermetic Build" approach—where the build environment is completely encapsulated in a container—is the industry standard for reproducibility.2.2 Docker Architecture on Intel MacsOn an Intel-based MacBook Pro (x86_64), Docker Desktop operates by running a lightweight Linux virtual machine (VM) using HyperKit (on older versions) or a custom QEMU-based implementation. The Docker daemon runs inside this Linux VM.4When we initiate a build container, we are essentially executing:macOS Host -> Linux VM (Docker Desktop) -> Ubuntu Container -> Kernel Compilation Process.This architecture allows us to use standard Linux build tools (apt, bash, make) without compatibility layers. The performance penalty of virtualization on Intel Macs is negligible for compilation tasks compared to the stability benefits.132.3 Constructing the Build ContainerTo ensure a stable build, we must define a Dockerfile that creates an Ubuntu environment populated with the precise dependencies required for Clang-based kernel compilation. The etnperlong kernel uses the LLVM toolchain, which requires specific libraries like libncurses, libssl, and python3.The following analysis details the necessary components of the build environment:Table 1: Build Environment Dependency AnalysisPackagePurpose in Kernel CompilationNecessitybuild-essentialProvides gcc, g++, make. Even when compiling with Clang, GCC headers and Make are required for the build infrastructure.CriticalbcArbitrary precision calculator language, used by Kconfig to calculate memory offsets and stack sizes.Criticalbison & flexParser generators used to process the .config file and Device Tree definitions.Criticallibssl-devProvides OpenSSL headers required for signing modules and generating kernel keypairs (certs).Criticallibelf-devRequired for the objtool utility which validates stack metadata and ORC unwind tables.Criticalpython3Modern kernels use Python scripts for Kconfig analysis and DTB (Device Tree Blob) generation.CriticalgitEssential for cloning the source tree and managing versions/submodules (like KernelSU).CriticalcpioUsed to create the initramfs archive, although raphael typically uses a prebuilt ramdisk.RecommendedThe Docker container must be configured to mount the host's directory to persist the build artifacts. This allows the user to edit code in a macOS IDE (like VS Code) while the container handles the compilation.33. Kernel Source Selection and Validation3.1 Landscape of Raphael KernelsThe development landscape for the Redmi K20 Pro is mature. Several kernel projects exist, but few are maintained for Android 15.LineageOS/CyanogenMod Trees: These are the most stable but often lack the "experimental" features required for Docker (e.g., specific netfilter configurations) or KernelSU support out of the box.15Sovient/Star/F1xy Kernels: These are performance-oriented kernels. While they often contain optimizations, they can be unstable or lack the specific configuration cleanliness required for a reliable Docker environment.8etnperlong/kernel_xiaomi_raphael_bool-x: This repository is identified as a fork of the "Bool-X" kernel, specifically maintained for newer Android versions (A14/A15). Crucially, the snippet analysis reveals commits such as "kernelsu: make KernelSU optional" and updates to lz4 and erofs, confirming its suitability for the target environment.53.2 The etnperlong Source AnalysisThe selection of etnperlong/kernel_xiaomi_raphael_bool-x is driven by three key factors found in the research material:KernelSU Integration: The repository history shows explicit submodule integration for KernelSU. This reduces the engineering effort required to manually patch the kernel, although verification of the KernelSU version is required.5Clang Optimization: The repository includes .clang-format and configurations for LLVM, implying it is optimized for compilation with modern Clang toolchains (Proton or AOSP Clang), which yield better performance on the Snapdragon 855 than legacy GCC.5Filesystem Support: The inclusion of patches for erofs (Enhanced Read-Only File System) is non-negotiable for Android 15. Android 13+ mandates EROFS for system partitions in many GSI (Generic System Image) and custom ROM configurations to save space and improve random read speeds. A 4.14 kernel without these backports would fail to mount the system partition, leading to a "bootloop".53.3 Toolchain Selection: Proton ClangFor 4.14 kernels, the industry standard in the custom ROM community is "Proton Clang" or "Azure Clang." These are prebuilt toolchains that bundle LLVM, Clang, LLD (Linker), and standard Linux binutils. Using the system GCC from the Ubuntu container is discouraged as it may produce binaries incompatible with the Android Bionic C library or specific Qualcomm optimizations. We will target a specific version of Proton Clang (e.g., version 13 or newer) to ensure compatibility with the etnperlong source code.184. Deep Dive: KernelSU Integration Strategy4.1 Mechanism of ActionKernelSU differs fundamentally from Magisk. Magisk operates by patching the boot.img ramdisk to hijack the init process. KernelSU operates in kernel space, hooking system calls to manage root privileges. This provides a higher degree of stealth, as userspace applications cannot easily detect the su binary since it doesn't exist in the traditional filesystem path until explicitly granted.204.2 Integration Logic for Non-GKI (4.14)Official KernelSU support is streamlined for GKI kernels (5.10+). For the legacy 4.14 kernel on raphael, we rely on the "Legacy" integration method.There are two primary methods for 4.14:KProbes (Kernel Probes): This is the preferred method. It uses the kernel's dynamic tracing capabilities to hook functions without modifying source code heavily. However, CONFIG_KPROBES must be enabled.2Manual Hooking: If KProbes are unstable or unsupported by the specific kernel tree, hardcoded hooks must be patched into the filesystem and process management code.The etnperlong repository appears to use a submodule approach, likely utilizing manual hooks or KProbes depending on the specific commit. The presence of "kernelsu: make KernelSU optional" in the commit log suggests a Kconfig toggle has been added.54.3 Configuration ConflictsKernelSU has a known conflict with overlayfs when used in "Magic Mount" mode (similar to Magisk modules). If CONFIG_OVERLAY_FS is not enabled, KernelSU modules will not function. Since Docker also requires CONFIG_OVERLAY_FS, this creates a synergistic requirement. However, care must be taken with CONFIG_KPROBES. Some hardened Android kernels disable this for security. We must explicitly enable CONFIG_KPROBES, CONFIG_HAVE_KPROBES, and CONFIG_KPROBE_EVENTS in the defconfig to ensure KernelSU functions correctly.25. Docker Support: The Kernel Configuration Matrix5.1 The check-config.sh StandardThe Moby Project provides a script, check-config.sh, which audits a kernel's configuration for Docker compatibility. Android kernels typically fail this check miserably, missing critical namespaces and cgroup controllers. Our primary engineering task is to transition the raphael_defconfig from "Red" (Missing) to "Green" (Enabled) for all critical parameters.225.2 Namespace IsolationNamespaces are the foundation of containerization, allowing processes to have a unique view of the system.User Namespace (CONFIG_USER_NS): Often disabled in Android due to security vulnerabilities (CVEs). However, it is essential for running rootless containers or mapping container users to non-root host users. We must enable this.24PID Namespace (CONFIG_PID_NS): Allows containers to have their own Process ID 1.Network Namespace (CONFIG_NET_NS): Critical for Docker's bridge networking. Without this, containers cannot have isolated IP addresses.5.3 Control Groups (cgroups)Android uses cgroups extensively for process lifecycle management (freezing background apps). Docker requires specific cgroup controllers that might be disabled or configured differently.CONFIG_CGROUP_DEVICE: Mandatory. Controls device access (allow/deny) for containers.CONFIG_MEMCG (Memory Control Group): Often disabled on phones to save overhead. Docker needs this to enforce memory limits on containers. Enabling this incurs a slight performance penalty on memory access, which is an acceptable trade-off for this project.26CONFIG_CGROUP_BPF: Required for newer systemd versions and cgroup v2 support, though on 4.14 this might be limited.5.4 Networking StackAndroid 4.14 kernels often strip out standard Linux networking features in favor of Android-specific implementations (like the now-deprecated xt_qtaguid).CONFIG_BRIDGE: Must be enabled as a built-in module (=y) or loadable module (=m). This allows Docker to create the docker0 bridge interface.CONFIG_VETH: Virtual Ethernet. Required to connect the container's network namespace to the bridge.CONFIG_NETFILTER_XT_MATCH_ADDRTYPE: Required for Docker's routing logic.CONFIG_IP_NF_TARGET_MASQUERADE: Essential for outbound container traffic (NAT).65.5 File SystemsCONFIG_OVERLAY_FS: Docker's preferred storage driver is overlay2. The legacy devicemapper driver is slow and deprecated. We must enable OverlayFS. Note that Android also uses OverlayFS for remount operations in dynamic partitions, so this is likely already present but might need specific flags.285.6 Comprehensive Configuration TableThe following table synthesizes the required configuration changes. These must be applied to arch/arm64/configs/raphael_defconfig.Table 2: Required Kconfig Modifications for Docker and KernelSUConfiguration FlagSettingComponentRationaleCONFIG_NAMESPACESyDockerGlobal switch for namespaces.CONFIG_NET_NSyDockerNetwork isolation.CONFIG_PID_NSyDockerProcess isolation.CONFIG_IPC_NSyDockerIPC isolation.CONFIG_USER_NSyDockerUser isolation.CONFIG_CGROUPSyDockerGlobal switch for cgroups.CONFIG_CGROUP_DEVICEyDockerDevice whitelist controller.CONFIG_CGROUP_CPUACCTyDockerCPU usage accounting.CONFIG_MEMCGyDockerMemory resource controller.CONFIG_VETHyNetworkVirtual ethernet pairs.CONFIG_BRIDGEyNetworkEthernet bridging.CONFIG_IP_NF_FILTERyNetworkNetfilter table required by Docker.CONFIG_IP_NF_TARGET_MASQUERADEyNetworkNAT for containers.CONFIG_NETFILTER_XT_MATCH_ADDRTYPEyNetworkRouting decision matching.CONFIG_NETFILTER_XT_MATCH_IPVSyNetworkLoad balancing support.CONFIG_OVERLAY_FSyStorageOverlay2 storage driver.CONFIG_KPROBESyKernelSUKernel dynamic tracing support.CONFIG_KPROBE_EVENTSyKernelSUInterface for KProbes.CONFIG_IKCONFIGyUtilityAllows check-config.sh to read /proc/config.gz.CONFIG_IKCONFIG_PROCyUtilityExposes config in procfs.Ref.66. Compilation Execution Protocol6.1 The Toolchain SetupInside the Docker container, we do not rely on apt-get install gcc-aarch64-linux-gnu. Instead, we clone Proton Clang. This toolchain is self-contained.Path setup:export PATH=/root/proton-clang/bin:$PATH6.2 The Build ScriptA robust build script is required to handle the complex set of environment variables required to cross-compile Android kernels. This script defines the architecture, the compiler, and the linker.Key variables:ARCH=arm64: Defines the target architecture.CC=clang: Forces the use of Clang instead of GCC.CLANG_TRIPLE=aarch64-linux-gnu-: Tells Clang which target to optimize for.CROSS_COMPILE=aarch64-linux-gnu-: Specifies the binutils (assembler, linker) prefix if not using LLVM's integrated tools.LD=ld.lld: Use the LLVM linker (faster and more accurate for LTO).196.3 LTO (Link Time Optimization)The etnperlong kernel likely has LTO enabled by default. LTO allows for whole-program optimization, resulting in a faster kernel. However, it is extremely memory intensive during the linking phase. On a Docker container running on a Mac, ld.lld may crash with OOM (Out of Memory). If this occurs, LTO must be disabled in the defconfig (# CONFIG_LTO_CLANG is not set).176.4 Managing "Dirty" BuildsThe kernel build system appends a "+" or "-dirty" string to the version string if the git repository has uncommitted changes. Since we are modifying raphael_defconfig, the build will be marked dirty. To ensure modules load correctly (which enforce strict version matching), we should either commit the changes locally or set CONFIG_LOCALVERSION_AUTO=n in the config.307. Packaging and Deployment7.1 The Boot Image StructureThe boot.img on the Redmi K20 Pro consists of the kernel (Image.gz-dtb) and the ramdisk. The ramdisk contains the init binary and crucial configuration files (fstab).In modern Android, replacing the entire boot.img is risky because it might overwrite Magisk patches or ROM-specific init scripts.7.2 AnyKernel3 StrategyWe will use "AnyKernel3" to inject only the compiled kernel image into the existing boot partition. This preserves the current ramdisk. AnyKernel3 is a scripted zip file flashable via TWRP (Team Win Recovery Project). It locates the boot partition, unpacks it, replaces the kernel binary, repackages it, and flashes it back.167.3 Android Verified Boot (AVB)The Redmi K20 Pro uses AVB 2.0 (vbmeta). Flashing a custom kernel breaks the cryptographic signature of the boot partition. The device bootloader must be unlocked. Additionally, it is often necessary to flash a "vbmeta disabler" or run the command fastboot --disable-verity --disable-verification flash vbmeta vbmeta.img to prevent the bootloader from rejecting the unsigned kernel.318. Runtime Configuration and Troubleshooting8.1 The Cgroup Mount IssueBy default, Android mounts cgroups in a specific hierarchy optimized for its task management (schedtune, cpuset). Docker expects a standard Linux cgroup mounting at /sys/fs/cgroup. Even with the correct kernel config, Docker will fail to start if the filesystem hierarchy is wrong.We must execute a script upon boot (via Termux boot-script or a Magisk service.d script) to remount cgroups in a layout Docker understands.328.2 Networking RoutingAndroid uses policy-based routing with multiple routing tables to handle Wi-Fi vs. LTE data. Docker creates a standard bridge (docker0). Often, the Android networking stack (ConnectivityService) will block or ignore traffic from the Docker bridge. We may need to add ip rule exceptions or disable specific Android firewall rules (iptables) to allow container traffic to flow.328.3 Kernel Panics and DebuggingIf the kernel fails to boot (bootloop), we must retrieve the "last kmsg" (kernel message buffer) from the previous boot. On the Snapdragon 855, this is stored in a persistent RAM region usually accessible at /sys/fs/pstore/console-ramoops. Analyzing this log is the only way to diagnose early boot failures caused by incompatible drivers or configuration conflicts.339. Step-by-Step Implementation Guide9.1 Phase I: Host Environment SetupObjective: Create the Docker container on macOS.Prepare the Workspace:Open Terminal.app on macOS.Bashmkdir -p ~/raphael_kernel_project/build_artifacts
cd ~/raphael_kernel_project
Define the Dockerfile:Create Dockerfile with the following content. This image encapsulates all tools required for the build.DockerfileFROM ubuntu:22.04
ENV DEBIAN_FRONTEND=noninteractive

# Core build tools
RUN apt-get update && apt-get install -y \
    git make build-essential bc bison flex \
    libssl-dev libelf-dev libncurses5-dev \
    python3 python3-pip python-is-python3 \
    curl wget zip unzip tar cpio \
    rsync lz4 zstd \
    && rm -rf /var/lib/apt/lists/*

# Set up working directory
WORKDIR /src
Build and Launch Container:Bashdocker build -t kernel-builder.
docker run -it --name raphael-build-env \
    -v $(pwd):/src \
    kernel-builder
We are now inside the Ubuntu environment.9.2 Phase II: Source Code AcquisitionObjective: Download the Kernel Source and Toolchain.Clone the Kernel:We use the etnperlong repository, targeting the main branch which contains the latest Android 15 and KSU patches.Bashgit clone --depth=1 https://github.com/etnperlong/kernel_xiaomi_raphael_bool-x -b main kernel_source
Clone the Toolchain (Proton Clang):We download a prebuilt Clang toolchain known for stability with 4.14 kernels.Bashgit clone --depth=1 https://github.com/kdrag0n/proton-clang toolchain/clang
Check KernelSU:Navigate to kernel_source/drivers/kernelsu. If empty, initialize it.Bashcd kernel_source
# If the directory exists but is empty (submodule):
git submodule update --init --recursive
# If it doesn't exist, or you want the latest version via script:
curl -LSs "https://raw.githubusercontent.com/tiann/KernelSU/main/kernel/setup.sh" | bash -s v0.9.5
Note: Use v0.9.5 for kernel 4.14 compatibility unless the repo specifically documents support for newer versions.29.3 Phase III: Configuration (The Defconfig)Objective: Enable Docker and KSU flags.Setup Environment Variables:Export the path to the toolchain.Bashexport PATH=/src/toolchain/clang/bin:$PATH
export ARCH=arm64
export SUBARCH=arm64
Generate Initial Config:Load the device's default configuration.Bashmake O=out raphael_defconfig
Edit the Configuration:We will use menuconfig for a visual interface, or edit .config directly. menuconfig is safer as it handles dependencies.Bashmake O=out menuconfig
Navigate and Enable the following:General setup -> Control Group support:Enable Memory controller (CONFIG_MEMCG)Enable Device controller (CONFIG_CGROUP_DEVICE)Enable CPU controller (CONFIG_CGROUP_CPUACCT)General setup -> Namespaces:Enable User namespace (CONFIG_USER_NS)Ensure all others (UTS, IPC, PID, NET) are enabled.Networking support -> Networking options:Enable 802.1d Ethernet Bridging (CONFIG_BRIDGE)Network packet filtering framework (Netfilter):IP: Netfilter Configuration -> IPv4 Network Address Translation (CONFIG_IP_NF_NAT) -> MASQUERADE target support.File systems:Enable Overlay filesystem support (CONFIG_OVERLAY_FS)General setup -> Kernel Performance Events And Counters:Enable Kernel Probes (CONFIG_KPROBES) (Critical for KSU).Exit and Save.Save the New Defconfig (Optional but Recommended):Bashmake O=out savedefconfig
cp out/defconfig arch/arm64/configs/raphael_docker_defconfig
9.4 Phase IV: CompilationObjective: Build the kernel image (Image.gz-dtb).Execute Build Command:We use a complex make command to specify the Clang toolchain variables.Bashmake O=out -j$(nproc --all) \
    CC=clang \
    CROSS_COMPILE=aarch64-linux-gnu- \
    CROSS_COMPILE_ARM32=arm-linux-gnueabi- \
    CLANG_TRIPLE=aarch64-linux-gnu- \
    LD=ld.lld \
    AR=llvm-ar \
    NM=llvm-nm \
    OBJCOPY=llvm-objcopy \
    OBJDUMP=llvm-objdump \
    STRIP=llvm-strip \
    Image.gz-dtb dtbo.img
Monitor Output:The build will take time. Watch for errors regarding openssl (install libssl-dev) or pahole (install dwarves or disable CONFIG_DEBUG_INFO_BTF if present).9.5 Phase V: Packaging with AnyKernel3Objective: Create a flashable ZIP.Prepare AnyKernel3:Bashcd /src
git clone https://github.com/osm0sis/AnyKernel3
cd AnyKernel3
Copy Artifacts:Bashcp../kernel_source/out/arch/arm64/boot/Image.gz-dtb.
cp../kernel_source/out/arch/arm64/boot/dtbo.img.
Configure anykernel.sh:Edit anykernel.sh to ensure it targets the correct partition for raphael.block=/dev/block/bootdevice/by-name/bootdo.devicecheck=1device.name1=raphaeldevice.name2=raphaelinZip It:Bashzip -r9../Raphael_Docker_KSU_Kernel.zip * -x.git README.md *placeholder
9.6 Phase VI: Flashing and ValidationTransfer: Copy Raphael_Docker_KSU_Kernel.zip from the Mac to the phone.Flash: Reboot to Recovery (TWRP/OrangeFox). Backup Boot partition. Install the Zip. Reboot System.Verify KSU: Open KernelSU Manager app. Verify it reports "Working."Verify Docker:Install Termux.Grant Root.Run the check-config.sh script (downloaded via wget) to verify kernel flags.Run the cgroup mount script (see section 8.1).Start dockerd.Run docker run hello-world.10. ConclusionBy adhering to this protocol, the engineering limitation of the legacy Snapdragon 855 platform is circumvented. We effectively modernize the Linux 4.14 kernel to support contemporary containerization standards required by Docker, while simultaneously implementing the KernelSU security model. The usage of a Dockerized build environment on the macOS host ensures that the compilation process is repeatable, hermetic, and immune to cross-platform filesystem anomalies. This results in a Redmi K20 Pro capable of functioning as a pocketable, ARM64-based container server running Android 15.Citations:.1